% You should summarise your project, emphasising your key
% achievements and significant drawbacks to your work, and
% discuss future directions your work could be taken in.
This project successfully managed to create an optimal solver for the Kilominx - the first of its kind - by following in the footsteps of the work done by Korf decades ago to create an optimal solver for the Rubik's Cube. The iterative-deepening A* (IDA*) solver successfully manages to utilise a number of different pattern databases for the Kilominx as admissible heuristics, using them to prune the massive search tree and guide the search algorithm to an optimal solution. The pattern databases make use of a linear algorithm to compute database indices for Kilominx states, using a form of permutation encoding called Lehmer codes.

Results from a number of experimental test runs on the solver show that randomly-scrambled Kilominx states up to a depth of 10 can be solved almost instantly, and states of depth 13 can be solved in about 1.7 hours on average. The maximum depth at which an optimal solution was found was depth 14. While this does not improve on the lower bound for the Kilominx's God's Number, the predicted average solve time for a state of depth 19 (which would prove a new lower bound) is over 9000 years of CPU time, which is infeasible for my solver to do.

Future work on the project could investigate newer algorithms for optimally solving twisty puzzles, such as Feather's Algorithm \cite{feather}, with a goal of improving solve times and the maximum solution depth. Alternatively, a more human-interaction approach could be taken, looking at improving the user interface to make it easier to use by adding a GUI with 3D models, or by using computer vision to make it easier to input a Kilominx state.