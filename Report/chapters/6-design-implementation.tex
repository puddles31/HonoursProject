\section{Modelling the Puzzles}
In order to ensure both the Rubik's Cube and the Kilominx can be used interchangeably in the code for populating pattern databases and with the IDA* search algorithm, an interface is defined to represent a "twisty puzzle", which both the Rubik's Cube and Kilominx implement. Similar interfaces are defined for the move controllers, moves and colours in order to ensure that the code is as reusable as possible. 

\subsection{Representing the State for a Rubik's Cube}
The state of the Rubik's Cube was modelled similarly to how it was described by Korf in his paper \cite{korf}, but with some changes. Instead of using a single array for all 20 cubies, I chose to use two arrays: one for the 12 edge cubies and the other for the 8 corner cubies. This improves the clarity of the code without a significant compromise on speed/efficiency. Representing the cube as arrays of cubies allows for very quick manipulation of the cube. This is important later on for the IDA* algorithm, as moves need to be made on the cube many, many times - the faster the moves can be performed, the faster the IDA* algorithm will be able to search for an optimal solution.

% ADD A DIAGRAM OF A RUBIK'S CUBE WITH CUBIE LABELS

Cubies are modelled as a class with two fields: an index (which signifies the cubie's initial position and colours) and an orientation. Since the maximum value for the index is 19 and the maximum value for the orientation is 2, both fields can fit comfortably in byte data types. This reduces how much memory is required to store a cube state.

For each corner and edge cubie on the cube, there is an associated constant value which holds the cubie's initial position in the corner/edge array. These constants are used when accessing cubies at specific positions in order to increase readability (e.g. instead of accessing the cubie at index 0, access the cubie at position CORNER\_ULB).

The initial state (or the solved state) of the cube is defined with the white face on top and the red face at the front. Since the centre cubies of the faces can not move, each physical cube state can only be represented by the code in a single way. Therefore, the only way to represent a solved cube state is with the white face on top and the red face at the front. This makes it easier to check if a cube is solved, and it also makes it easier to determine how many moves away a state is from being solved when creating the pattern databases.

The chosen values for the corner cubie indices are important, as they are used to correctly determine which colours should appear on which faces. Corner cubies which are an odd number of quarter turns away from each other should also be an odd number of indices apart in the array - the same applies for cubies which are an even number of quarter turns away being an even number of indices apart. For example, the cubie in the up-left-back (ULB) corner can turn to the up-right-back (URB), up-left-front (ULF), and down-left-back (DLB) corners in a single quarter turn, and to the down-right-front (DRF) corner in three quarter turns; since the ULB cubie has an index of 0 (which is even), then the URB, ULF, DLB and DRF cubies should all be an odd number of indices away from 0.

When the cube is in a solved state, the initial orientation of all of the cubies is 0. Edge cubies can have an orientation of 0 (oriented) or 1 (flipped), where an edge is oriented if it can be solved using only U, D, L and R moves. Corner cubies can have an orientation of 0 (when the white/yellow side of the corner is on the top or bottom face), 1 (when the white/yellow side of the corner is on the face clockwise from the top or bottom face), or 2 (when the white/yellow side of the corner is on the face counter-clockwise from the top or bottom face).

An enum is defined which holds the six different colours on the cube - white (W), green (G), red (R), blue (B), orange (O) and yellow (Y). The subset of colours that appear on a cubie are determined by its index, and colours are always returned by helper functions in the following order: the colour on the top/bottom face first, then the colour on the front/back face, and finally the colour on the left/right face. The default order of colours for cubies in their initial positions with an orientation of 0 is pre-defined, making it easy to return the colours in the correct order. However, after cubies have been moved about and are in different positions/orientations, it becomes a little more complicated to determine which colours appear on which faces. For edge cubies, if the orientation of the edge is 1 (denoting a flipped orientation) then the colours are returned in reverse order. For corner cubies, the order is determined by the orientation of the corner, whether the cubie's current position has an even or odd index, and whether the cubie is an even or odd number of indices away from its initial position. The colours can then be used to print the cube's state in a human-readable format.

\subsection{Representing the State for a Kilominx}
The Kilominx is represented very similarly to the Rubik's Cube, but with some key changes. Since the Kilominx is made up of only "corner" cubies, I chose to represent the state as a single array of 20 cubies.

The initial state of the Kilominx is also defined with the white face on top and the red face at the front. However, since there are no centre cubies on a Kilominx, there is no easy way to figure out the correct orientation of a scrambled Kilominx. This also creates further problems when creating pattern databases later on, as each physical Kilominx state can be represented by the code in $60\ (= 20 \text{ cubies} \cdot 3 \text{ orientations})$ different ways. So to get around this problem, I chose to fix one of the cubies in place, such that it is always in the same position and orientation - all of the other cubies are defined relative to this cubie. I arbitrarily chose to fix the up-front-left (UFL) cubie. Now, each physical state can only be represented in the code in a single way.

The indices of the cubies are important again for determining colour orders, but the reasoning behind which cubies are even and which are odd is different for the Kilominx. The faces of the Kilominx have the following priority order (going from highest to lowest): top/bottom, left/down-back-right, front/down-back-middle, right/down-back-left, down-left/back-right, and down-right/back-left. This priority order is used for a few things, including the return order of colours from helper functions for printing the Kilominx's state. When the Kilominx is in the initial state, any cubies which return their colours in a counter-clockwise order have an even index, and any cubies which return their colours in a clockwise order have an odd index.

%  maybe put the face/colour priorities in a table here?

The priority order defined above is also used to determine the orientation of the cubies \cite{kilominxorientation}. In the same way that the faces have a priority order, the colours also have a priority order (which is in the same order as the faces when the Kilominx is in the initial state): white/grey, light/dark-green, red/orange, light/dark-blue, beige/yellow, and pink/purple. Looking at a single cubie, the face which the highest-priority colour is on is compared to the highest-priority face the cubie is part of. There are three different cases - if the highest-priority colour is on:
\begin{itemize}
    \item the highest-priority face, the cubie has an orientation of 0.
    \item the face clockwise from the highest-priority face, the cubie has an orientation of 1.
    \item the face counter-clockwise from the highest-priority face, the cubie has an orientation of 2.
\end{itemize}

% example of above?

A different enum is defined for the colours on a Kilominx: white (Wh), dark-green (DG), red (Re), dark-blue (DB), yellow (Ye), purple (Pu), light-blue (LB), beige (Be), pink (Pi), light-green (LG), orange (Or), and grey (Gy). Two characters are used for the Kilominx's colours to prevent confusion between colours that start with the same letter (e.g. 'G' could refer to dark-green, light-green, or grey). The method to determine which colours and what order to display them is the same as with the Rubik's Cube, albeit with some slight logic changes to match the priority orders defined above.

\subsection{Making Moves}
\label{subsection:moves}
Both the Rubik's Cube and the Kilominx hold a reference to a separate move controller object which contains all of the logic used to make moves on the puzzle. This logic is kept separate from the code used to define the Rubik's Cube and Kilominx in order to make the code more readable.

Both move controllers contain an enum which defines the available moves for the puzzle associated with the move controller. Each move has an associated inverse move (which defines the move that undoes it, e.g. $U'$ is the inverse of $U$) and a base move (which defines the face the move acts on, e.g. $F$ is the base move of $F2$ and $F'$).

Moves on the puzzles are made by performing the following basic operations on different cubies or sets of cubies:
\begin{itemize}
    \item Rotation of cubies: A set of cubies are swapped with each other in the cubie array, resulting in the positions of the cubies being "rotated" in a cycle.
    \item Edge orientation flip: The orientation of an edge on the cube is flipped from 0 to 1, or from 1 to 0.
    \item Cubie orientation increase: The orientation of a corner on the cube or any cubie on the Kilominx is adjusted by adding either 1 or 2, and then is reduced by modulo 3 in order to keep the orientation within the range 0 to 2.
\end{itemize}
These three basic operations are enough to define any possible move on the puzzles. 

% example of a move?

For the Kilominx, moves which affect the fixed UFL cubie (any moves on the U, L and F faces) are performed as normal, but are then followed by a full rotation of the Kilominx in order to reposition the fixed cubie back to the UFL corner with the correct orientation. This allows the fixed cubie to move around the Kilominx relative to the rest of the cubies, while ensuring that each physical state can only be represented in one way.

As discussed by Korf in his paper \cite{korf}, when iterating over possible moves in the IDA* search, redundant moves can be skipped over in order to reduce the branching factor of the search. A move is skipped if the move is on the same face as the previous move, or if the move is on a non-adjacent face to the previous move and the moves are not performed in the correct order (up, left, front, right, back-left, back-right, down-left, down-right, down-back-left, down-back-right, down-back, down). For example, on a Kilominx, if the previous move was on the down-left (DL) face, and the next move is on the up (U) face, then the move will be skipped as the moves are not in the correct order. Java Streams are used to help simplify these checks, improving the clarity of the code.

\section{Pattern Databases}
Similar to how an interface is defined for a twisty puzzle, an abstract class is defined for a general pattern database. The abstract class contains implementation details which are the same for all pattern database subclasses, but cannot be directly instantiated because the way database indices are calculated differ slightly depending on the cubie selections for the pattern database subclasses.

A pattern database is essentially a large lookup table, which I chose to model as an array of bytes. Each table contains the number of moves required to solve a specific pattern - a subset of cubies (which are different depending on which pattern database subclass is used and what parameters are provided to the subclass constructor) - in every possible state, where each byte stores the number of moves for a single state. This results in a table that can be used as an admissible heuristic for the IDA* algorithm, as the number of moves required to solve any subset of cubies will always be less than or equal to the number of moves required to solve the entire puzzle state. Multiple pattern databases can be used together to improve the heuristic result by taking the maximum of the values returned by each pattern database for the current state.

Ideally we want the pattern databases to be as large as possible - the more cubies that are used in a pattern, the more accurate the heuristic becomes, which in turn improves the speed of the IDA* search. However, increasing the number of cubies used in a pattern exponentially increases the number of states (and so the amount of memory required to store the pattern database). So in practice, we should choose a number of cubies that is small enough to keep the pattern database in memory, but large enough to give a good heuristic.

We also need to decide what pattern of cubies we want to use for each pattern database. Culberson and Schaeffer note that "...experiments suggest that the best pattern databases are the ones that reduce the problem to a simpler one whose solution requires little or no interference with the placing of the target pattern." \cite{patterndatabases}. However, since every move for both the Rubik's Cube and the Kilominx affects the positions and orientations of cubies on multiple faces, there is no easy choice for a pattern of cubies to use. Korf chooses to make three pattern databases for the Rubik's Cube in his implementation: one containing all eight corner cubies, and two for the edge cubies (each containing six of the 12 edge cubies) \cite{korf}. This is a logical choice to make for the Rubik's Cube, as the corners and edges calculate their database indices slightly differently, but this isn't possible with the Kilominx as the puzzle is made up entirely of "corner" cubies, and as discussed above, we can't make a single pattern database for all of the Kilominx cubies as the table would require an absolutely enormous amount of memory.

For the Rubik's Cube, I chose to use three pattern databases in a similar manner to what Korf used: one with all eight corner cubies, and two with a number of edge cubies. However, since modern computers have far more memory than they did in 1995 (when Korf's paper was published), I was able to include seven edge cubies in each edge cubie pattern database (with two cubies appearing in both patterns). This gives a notable increase in speed for the IDA* search without requiring too much memory.

For the Kilominx, I chose to create two different pattern types for the pattern databases: the first selects five cubies that are part of the same face, and the second selects four cubies that are as far apart as possible. 12 face pattern databases are used - one for each face - and 5 sparse pattern databases are used - such that each cubie on the Kilominx appears in exactly one of these pattern databases. Using two different patterns and using a large number of them ensures many different states are covered, improving the accuracy of the heuristic. The number of cubies used in each pattern are also low enough to keep the size of the pattern databases small enough to fit in memory.

However, due to the fixed cubie in the UFL corner, some of the patterns used for the Kilominx pattern databases are slightly altered - this is because the fixed cubie is always in the same position and orientation, so it is no longer a part of the permutation of cubies for the pattern databases. Wherever the UFL cubie is used in a pattern database, it is instead replaced by a nearby cubie in order to keep the general pattern shapes consistent.

When a pattern database is initialised, we need to know how big the database will be ahead of time in order to create the array of bytes. This can be found by calculating the number of permutations that exist for the subset of cubies provided. For example, each Kilominx face pattern database considers 5 of the 19 cubies (excluding the 20th cubie, which is fixed in the UFL position), so the parameters $n$ and $k$ are set to 19 and 5 respectively. There are $^nP_k = {}^{19}P_5$ different permutations the cubies can be in (ignoring their orientations), and each of the 5 cubies can be in one of 3 orientations. Hence, the total number of states in the pattern database is $^{19}P_5 \cdot 3^5 = 339072480$.

\subsection{Database Index Calculation}
In order to calculate the database index for a given puzzle state, the Lehmer code of the permutation of the cubie indices used in the pattern is calculated and converted into base-10, and is then offset based on the permutation of the cubie orientations. This allows us to map each possible state for a pattern database to a unique index in the array.

The implementation follows the same linear algorithm outlined in \textbf{\hyperref[subsection:lehmercodes]{Section 2.1.4}}, but with some minor changes to improve its efficiency: the first digit of the Lehmer code isn't directly calculated because it is always equal to the first digit in the permutation, and instead of iterating through a bit string to count the number of ones that appear in it, we instead pre-compute a table which stores the number of ones that appear in the binary representations of all of the numbers that can be represented by the bit string, allowing for a constant lookup time. Similarly, a table is precomputed for all of the factorials that are needed to convert the Lehmer code into base-10 - by doing so ahead of time, we avoid needing to recursively calculate a factorial every time a database index is calculated.

\subsection{Populating Pattern Databases}
The pattern databases are populated using an iterative-deepening depth-first-search (IDDFS). While a breadth-first search (BFS) may initially seem like a better choice, the large branching factor of the puzzles (especially the Kilominx) mean that a very large number of states need to be kept in memory during search, which would eventually cause the BFS to run out of memory. Using an IDDFS means that only the path of states from the initial (solved) state to the current state needs to be kept in memory. However, this comes at the cost of search speed, as IDDFS will need to revisit lower depth states every time a depth level is completed.

Each node in the IDDFS search tree contains a puzzle state, the move used to get to the node, and the depth of the node. A stack is used to store the nodes, implemented using a double-ended queue (a deque). Starting with the node containing the initial puzzle state, nodes are popped off of the top of the stack and all possible moves from the node are iterated over (skipping moves where necessary, as explained in \textbf{\hyperref[subsection:moves]{Section 6.1.3}}), generating new nodes to push to the stack (up to the current depth limit). For each node that is encountered, the database value for the state is set to the number of moves needed to reach the state (the depth of the node). If the state had already been previously reached with a lower number of moves, then that value is kept instead. When the search tree has been fully explored up to the current depth limit, the depth limit is increased and the search repeats. This continues until every state has been reached and the pattern database is fully populated.

All of the pattern databases are populated ahead of time, as each IDDFS can take a long time to complete - especially for the larger Kilominx face pattern databases. Once all of the pattern databases have been populated, they do not need to be populated again.

\section{Searching for Solutions}
The puzzle solver is implemented as an abstract class, containing the bulk of the IDA* code, with the two subclasses containing code which is specific to the Rubik's Cube and Kilominx respectively (ensuring that they use the correct pattern databases).

The IDA* implementation is similar to the IDDFS implementation: nodes contain a puzzle state, the move used to get to the node, and the depth; the nodes are stored in a stack (implemented as a deque); nodes are generated by popping a node off of the top of the stack and iterating over all non-skipped moves; and the depth limit is increased whenever the current depth-bounded search tree is fully explored.

However, it differs from IDDFS in a few ways. First, the initial depth bound of the search is set to the maximum value returned by the pattern databases for the initial scrambled puzzle state. This helps reduce a lot of the unnecessary search at lower depth bounds, saving some time. Second, when new nodes are generated by iterating over moves from the current state, they are pushed to the stack in descending order of their estimated cost (implemented using a priority queue) - this results in the new top node of the stack having the lowest estimated cost, so the most promising area of the search tree is explored first. Third, newly generated nodes which have a greater estimated cost than the current bound get pruned from the search tree, ensuring that only nodes within the current bound limit are explored.

Once the solved state has been found, the IDA* search returns the solution path from the initial state to the solved state. The solution is guaranteed to be optimal, as the pattern databases are admissible heuristics.

\section{Interacting with the Puzzles}
A number of classes are defined to provide a way for the user to interact with the puzzles and the solvers.

The two terminal classes provide a command-line interface (CLI), allowing the user to view the current puzzle state in a human-readable format, make moves, and enter commands to manipulate the puzzles, including scrambling the puzzle with a specified number of moves, invoking the solver for the current puzzle state, and editing the current puzzle state. The edit command ensures that the new state is valid and can be solved by checking for duplicate cubies and performing the following parity checks \cite{parity}:
\begin{itemize}
    \item Corner Parity: the sum of the orientations of the corner cubies for the Rubik's Cube, or all cubies for the Kilominx, must be a multiple of 3.
    \item Edge Parity: the sum of the orientations of the edge cubies for the Rubik's Cube must be even.
    \item Permutation Parity: the sum of the number of swaps needed to place all of the cubies in their correct positions must be even.
\end{itemize}
In addition to this, the edit command doesn't allow the user to edit any fixed cubies, such as the centre cubies on the Rubik's Cube or the fixed cubie in the UFL corner on the Kilominx. This ensures that the orientation of the puzzle cannot be manually changed.

The GUI class provides a graphical user interface for the Rubik's Cube, providing mostly the same functionality as the CLI but with a better way of displaying the current cube state, and various hotkeys to allow the user to quickly make moves on the cube. The GUI was made with Java's Swing library, where the main window extends a JFrame and is composed of JPanels - one which contains the display of the cube state, and another which contains a terminal to allow the user to input commands and view move history. A GUI was also planned for the Kilominx, but due to time constraints it was not implemented.